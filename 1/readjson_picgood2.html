<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é¢±é¢¨ 3D ç‹€æ…‹åœ– (ç›¸å®¹ç‰ˆ)</title>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      display: flex; 
      height: 100vh; 
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f5f5f5;
    }
    #plot { 
      flex: 3; 
      background: white;
    }
    #node-info { 
      flex: 1; 
      padding: 20px; 
      background: white;
      border-left: 3px solid #4a90e2;
      overflow: auto;
      box-shadow: -2px 0 10px rgba(0,0,0,0.1);
    }
    #node-info h3 {
      color: #2c3e50;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    #node-info p {
      margin: 10px 0;
      color: #555;
      line-height: 1.6;
    }
    #node-info b {
      color: #2c3e50;
    }
    #node-info img {
      max-width: 100%;
      border-radius: 8px;
      margin-top: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 1.2em;
      color: #4a90e2;
      z-index: 1000;
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #4a90e2;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .hint {
      color: #888;
      font-style: italic;
      font-size: 0.9em;
    }
    #stats {
      margin-top: 20px;
      padding: 10px;
      background: #f0f8ff;
      border-radius: 5px;
      font-size: 0.85em;
    }
    .image-container {
      margin-top: 15px;
    }
    .image-wrapper {
      position: relative;
      margin-bottom: 10px;
    }
    .image-wrapper img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .image-caption {
      font-size: 0.85em;
      color: #666;
      margin-top: 5px;
      text-align: center;
    }
    .image-loading {
      text-align: center;
      padding: 20px;
      color: #999;
    }
  </style>
</head>
<body>
  <div id="plot"></div>
  <div id="node-info">
    <div class="hint">
      <p>ğŸ’¡ æç¤ºï¼šé»æ“Šåœ–ä¸­çš„ç¯€é»æŸ¥çœ‹è©³ç´°è³‡è¨Š</p>
      <p>ğŸ–±ï¸ å¯ä»¥æ‹–å‹•æ—‹è½‰è¦–è§’ã€æ»¾è¼ªç¸®æ”¾</p>
    </div>
    <div id="stats"></div>
  </div>
  <div id="loading">
    <div class="spinner"></div>
    <div>è¼‰å…¥è³‡æ–™ä¸­...</div>
  </div>

  <script type="module">
  // ==============================================================================
  // è¼‰å…¥è³‡æ–™ (æ”¯æ´ .json å’Œ .json.gz)
  // ==============================================================================
  async function loadData(filename) {
    try {
      const response = await fetch(filename);
      
      if (filename.endsWith('.gz')) {
        const buffer = await response.arrayBuffer();
        const decompressed = pako.inflate(new Uint8Array(buffer), { to: 'string' });
        return JSON.parse(decompressed);
      } else {
        return await response.json();
      }
    } catch (error) {
      console.error('è¼‰å…¥è³‡æ–™å¤±æ•—:', error);
      document.getElementById('loading').innerHTML = `
        <div style="color: red;">âŒ è¼‰å…¥å¤±æ•—</div>
        <div style="font-size: 0.9em; margin-top: 10px;">è«‹ç¢ºèªæª”æ¡ˆå­˜åœ¨: ${filename}</div>
      `;
      throw error;
    }
  }

  // ==============================================================================
  // ğŸ–¼ï¸ è¼‰å…¥é¢±é¢¨åœ–ç‰‡ (å„ªåŒ–ç‰ˆ - æ”¯æ´å¾€å›å˜—è©¦ TC ID)
  // ==============================================================================
  /**
   * ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ TC ID (å¾€å›æœ€å¤š 10 å€‹)
   * @param {string} tcId - åŸå§‹é¢±é¢¨ç·¨è™Ÿ (ä¾‹å¦‚ "202018W")
   * @returns {Array<string>} - TC ID åˆ—è¡¨ (ä¾‹å¦‚ ["202018", "202017", ..., "202009"])
   */
  function generateTcIdCandidates(tcId) {
    // ç§»é™¤æœ€å¾Œçš„å­—æ¯ (K æˆ– W)
    const tcIdNum = tcId.slice(0, -1);
    const suffix = tcId.slice(-1);
    
    // è§£æå¹´ä»½å’Œç·¨è™Ÿ
    const year = tcIdNum.slice(0, 4);  // ä¾‹å¦‚ "2020"
    const num = parseInt(tcIdNum.slice(4));  // ä¾‹å¦‚ 18
    
    const candidates = [];
    
    // å¾åŸå§‹ç·¨è™Ÿé–‹å§‹å¾€å›å˜—è©¦æœ€å¤š 10 å€‹
    for (let i = 0; i < 10; i++) {
      const tryNum = num - i;
      
      // å¦‚æœç·¨è™Ÿå°æ–¼ 1ï¼Œåœæ­¢ (ä¾‹å¦‚ 202005 â†’ 202001 å°±åœæ­¢)
      if (tryNum < 1) break;
      
      // çµ„åˆæˆå®Œæ•´çš„ TC ID (æ ¼å¼: YYYYNNï¼Œä¾‹å¦‚ "202018")
      const tryTcId = `${year}${String(tryNum).padStart(2, '0')}`;
      candidates.push(tryTcId);
    }
    
    return candidates;
  }

  /**
   * è¼‰å…¥é¢±é¢¨åœ–ç‰‡ï¼Œå˜—è©¦å¤šå€‹ä¾†æºç›´åˆ°æˆåŠŸ
   * @param {string} tcId - é¢±é¢¨ç·¨è™Ÿ (ä¾‹å¦‚ "202018W")
   * @param {string} time - æ™‚é–“å­—ä¸² (ä¾‹å¦‚ "2020-08-15 06:00:00")
   * @param {number} order - é †åºç·¨è™Ÿ
   * @returns {Promise<HTMLImageElement>} - æˆåŠŸè¼‰å…¥çš„åœ–ç‰‡å…ƒç´ 
   */
  function loadTyphoonImage(tcId, time, order) {
    return new Promise((resolve) => {
      // ç”Ÿæˆ TC ID å€™é¸åˆ—è¡¨ (å¾€å›æœ€å¤š 10 å€‹)
      const tcIdCandidates = generateTcIdCandidates(tcId);
      
      // æ ¼å¼åŒ–æ™‚é–“ (ç§»é™¤å‰å…©ä½å¹´ä»½ï¼Œä¾‹å¦‚ "2020-08-15 06:00:00" â†’ "200815.0600")
      // å‡è¨­ time æ ¼å¼ç‚º "YYYY-MM-DD HH:MM:SS"
      const timeFormatted = time.replace(/[-:\s]/g, '').slice(2, 11); // "200815060" â†’ "200815.06"
      const timeStr = timeFormatted.slice(0, 6) + '.' + timeFormatted.slice(6, 8) + '00';
      
      // ğŸ”§ ç‚ºæ¯å€‹ TC ID ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„åœ–ç‰‡ URL
      const allCandidates = [];
      
      for (const tryTcId of tcIdCandidates) {
        allCandidates.push(
          `https://agora.ex.nii.ac.jp/digital-typhoon/wnp/by-name/${tryTcId}/1/512x512/GMS4${timeStr}.${tryTcId}.jpg`
        );
        allCandidates.push(
          `https://agora.ex.nii.ac.jp/digital-typhoon/wnp/by-name/${tryTcId}/4/512x512/HMW8${timeStr}.${tryTcId}.jpg`
        );
        allCandidates.push(
          `https://agora.ex.nii.ac.jp/digital-typhoon/wnp/by-name/${tryTcId}/4/512x512/HMW9${timeStr}.${tryTcId}.jpg`
        );
      }
      
      // æœ€å¾ŒåŠ å…¥å‚™ç”¨åœ–ç‰‡
      allCandidates.push(
        `https://media.istockphoto.com/id/1503385646/zh/%E7%85%A7%E7%89%87/portrait-funny-and-happy-shiba-inu-puppy-dog-peeking-out-from-behind-a-blue-banner-isolated-on.jpg?s=612x612&w=0&k=20&c=j6W1QMERTVgCfKQq7aWLv4m4vUmzHEaC8Iul9883-iE=`
      );

      const img = document.createElement('img');
      img.alt = `é¢±é¢¨ ${tcId} åœ–ç‰‡`;
      img.style.maxWidth = "100%";
      img.style.borderRadius = "8px";
      img.style.boxShadow = "0 2px 8px rgba(0,0,0,0.15)";

      let currentIndex = 0;

      function tryLoadImage() {
        if (currentIndex >= allCandidates.length) {
          // æ‰€æœ‰ä¾†æºéƒ½å¤±æ•—,å›å‚³ null
          console.log(`âŒ æ‰€æœ‰ä¾†æºéƒ½å¤±æ•—: ${tcId}`);
          resolve(null);
          return;
        }

        const currentUrl = allCandidates[currentIndex];
        img.src = currentUrl;

        img.onload = function() {
          // æˆåŠŸè¼‰å…¥
          console.log(`âœ… æˆåŠŸè¼‰å…¥åœ–ç‰‡ [${currentIndex + 1}/${allCandidates.length}]: ${currentUrl}`);
          resolve(img);
        };

        img.onerror = function() {
          // è¼‰å…¥å¤±æ•—,å˜—è©¦ä¸‹ä¸€å€‹
          // console.log(`âŒ è¼‰å…¥å¤±æ•— [${currentIndex + 1}/${allCandidates.length}]: ${currentUrl}`);
          currentIndex++;
          tryLoadImage();
        };
      }

      tryLoadImage();
    });
  }

  /**
   * è¼‰å…¥å¤šå¼µé¢±é¢¨åœ–ç‰‡ (æœ€å¤š 5 å¼µï¼Œåƒ…é™è¥¿åŒ—å¤ªå¹³æ´‹)
   * @param {Array} tcIds - é¢±é¢¨ç·¨è™Ÿåˆ—è¡¨
   * @param {Array} times - æ™‚é–“åˆ—è¡¨
   * @param {Array} orders - é †åºåˆ—è¡¨
   * @param {HTMLElement} container - åœ–ç‰‡å®¹å™¨
   */
  async function loadMultipleTyphoonImages(tcIds, times, orders, container) {
    // æ¸…ç©ºå®¹å™¨
    container.innerHTML = '<div class="image-loading">ğŸ–¼ï¸ è¼‰å…¥åœ–ç‰‡ä¸­...</div>';

    // ğŸ”§ ç¯©é¸è¥¿åŒ—å¤ªå¹³æ´‹é¢±é¢¨ (K æˆ– W çµå°¾) ä¸¦é™åˆ¶æœ€å¤š 5 å¼µ
    const maxImages = 5;
    const imagePromises = [];

    for (let i = 0; i < tcIds.length; i++) {
      const tcId = String(tcIds[i]);
      
      // ç¯©é¸é¢±é¢¨ç·¨è™Ÿ: K æ˜¯ç‰¹æ®Šç·¨è™Ÿ, W æ˜¯è¥¿åŒ—å¤ªå¹³æ´‹
      if (["K", "W"].includes(tcId.slice(-1))) {
        imagePromises.push(
          loadTyphoonImage(tcId, String(times[i]), orders[i])
        );
      }

      // å¦‚æœå·²ç¶“æ”¶é›†åˆ° maxImages å¼µï¼Œåœæ­¢è¿´åœˆ
      if (imagePromises.length >= maxImages) {
        break;
      }
    }

    // å¦‚æœæ²’æœ‰ç¬¦åˆæ¢ä»¶çš„é¢±é¢¨
    if (imagePromises.length === 0) {
      container.innerHTML = '<div class="image-loading" style="color: #999;">âš ï¸ ç„¡è¥¿åŒ—å¤ªå¹³æ´‹é¢±é¢¨åœ–ç‰‡</div>';
      return;
    }

    // ç­‰å¾…æ‰€æœ‰åœ–ç‰‡è¼‰å…¥å®Œæˆ
    const images = await Promise.all(imagePromises);

    // ç§»é™¤ loading è¨Šæ¯
    container.innerHTML = '';

    // é¡¯ç¤ºæˆåŠŸè¼‰å…¥çš„åœ–ç‰‡
    let successCount = 0;
    images.forEach((img, index) => {
      if (img) {
        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        
        wrapper.appendChild(img);
        
        const caption = document.createElement('div');
        caption.className = 'image-caption';
        
        // æ‰¾åˆ°å°æ‡‰çš„åŸå§‹ index (å› ç‚ºå¯èƒ½æœ‰è¢«ç¯©é¸æ‰çš„)
        let originalIndex = 0;
        let validCount = 0;
        for (let j = 0; j < tcIds.length; j++) {
          if (["K", "W"].includes(String(tcIds[j]).slice(-1))) {
            if (validCount === index) {
              originalIndex = j;
              break;
            }
            validCount++;
          }
        }
        
        caption.textContent = `é¢±é¢¨ ${tcIds[originalIndex]} - ${times[originalIndex]}`;
        wrapper.appendChild(caption);
        
        container.appendChild(wrapper);
        successCount++;
      }
    });

    // å¦‚æœæ²’æœ‰ä»»ä½•åœ–ç‰‡è¼‰å…¥æˆåŠŸ
    if (successCount === 0) {
      container.innerHTML = '<div class="image-loading" style="color: #999;">âš ï¸ ç„¡å¯ç”¨åœ–ç‰‡</div>';
    } else {
      console.log(`âœ… æˆåŠŸè¼‰å…¥ ${successCount} å¼µåœ–ç‰‡`);
    }
  }

  // ==============================================================================
  // ğŸ”§ è™•ç†å…©ç¨®ä¸åŒçš„ JSON æ ¼å¼
  // ==============================================================================
  function processGraphData(graphData) {
    const nodes = graphData.nodes;
    let edgeData = {};
    let metadata = {};

    if (Array.isArray(graphData.edges)) {
      console.log('ğŸ”„ åµæ¸¬åˆ°èˆŠæ ¼å¼,æ­£åœ¨è½‰æ›é‚Šçš„åº§æ¨™...');
      
      const edge_x = [];
      const edge_y = [];
      const edge_z = [];
      
      for (const [u, v] of graphData.edges) {
        if (u >= nodes.length || v >= nodes.length) continue;
        
        edge_x.push(nodes[u].x);
        edge_y.push(nodes[u].y);
        edge_z.push(nodes[u].z);
        
        edge_x.push(nodes[v].x);
        edge_y.push(nodes[v].y);
        edge_z.push(nodes[v].z);
        
        edge_x.push(null);
        edge_y.push(null);
        edge_z.push(null);
      }
      
      edgeData = { x: edge_x, y: edge_y, z: edge_z };
      metadata = {
        total_nodes: nodes.length,
        total_edges: graphData.edges.length,
        sampled_edges: graphData.edges.length,
        sample_rate: 1.0
      };
      
      console.log(`âœ… å·²è½‰æ› ${graphData.edges.length} æ¢é‚Š`);
      
    } else if (graphData.edges && graphData.edges.x) {
      console.log('âœ… åµæ¸¬åˆ°å„ªåŒ–æ ¼å¼');
      edgeData = graphData.edges;
      metadata = graphData.metadata || {
        total_nodes: nodes.length,
        total_edges: edgeData.count || 0,
        sampled_edges: edgeData.count || 0,
        sample_rate: 1.0
      };
    } else {
      console.error('âŒ ç„¡æ³•è­˜åˆ¥çš„é‚Šæ ¼å¼');
      edgeData = { x: [], y: [], z: [] };
      metadata = { total_nodes: nodes.length, total_edges: 0, sampled_edges: 0, sample_rate: 0 };
    }

    return { nodes, edgeData, metadata };
  }

  // ==============================================================================
  // ä¸»ç¨‹å¼
  // ==============================================================================
  (async () => {
    try {
      // ğŸ”§ ä¿®æ”¹é€™è£¡ä¾†è¼‰å…¥ä¸åŒçš„æª”æ¡ˆ
      const graphData = await loadData('graph_data_full.json.gz');
      
      console.log('ğŸ“Š åŸå§‹è³‡æ–™:', graphData);
      
      const { nodes, edgeData, metadata } = processGraphData(graphData);
      
      console.log('ğŸ“Š è™•ç†å¾Œ:', { nodes: nodes.length, edges: edgeData });
      
      document.getElementById('loading').style.display = 'none';

      // ==============================================================================
      // ç¹ªè£½é‚Š
      // ==============================================================================
      const edgeTrace = {
        x: edgeData.x,
        y: edgeData.y,
        z: edgeData.z,
        mode: 'lines',
        type: 'scatter3d',
        line: { 
          color: 'rgba(150, 150, 150, 0.4)',
          width: 1
        },
        hoverinfo: 'skip',
        name: `æ™‚é–“æ¼”åŒ– (${metadata.sampled_edges} æ¢é‚Š)`
      };

      // ==============================================================================
      // ç¹ªè£½ç¯€é»
      // ==============================================================================
      const nodeColors = Array(nodes.length).fill('#4a90e2');
      const nodeTrace = {
        x: nodes.map(n => n.x),
        y: nodes.map(n => n.y),
        z: nodes.map(n => n.z),
        mode: 'markers',
        type: 'scatter3d',
        marker: {
          size: 5,
          color: nodeColors,
          opacity: 0.8,
          line: { width: 0.5, color: 'white' }
        },
        hovertext: nodes.map(n => n.info_text || `Node ${n.id}`),
        hoverinfo: 'text',
        name: `é¢±é¢¨ç‹€æ…‹ (${nodes.length} å€‹)`
      };

      // ==============================================================================
      // é…ç½®åœ–è¡¨
      // ==============================================================================
      const layout = {
        margin: { l: 0, r: 0, t: 0, b: 0 },
        scene: { 
          xaxis: { title: 'Layout X', showgrid: true },
          yaxis: { title: 'Layout Y', showgrid: true },
          zaxis: { title: 'Layout Z', showgrid: true },
          camera: {
            eye: { x: 1.5, y: 1.5, z: 1.5 }
          },
          bgcolor: '#f8f9fa'
        },
        hovermode: 'closest',
        showlegend: true,
        legend: {
          x: 0.02,
          y: 0.98,
          bgcolor: 'rgba(255,255,255,0.9)'
        }
      };

      const config = {
        responsive: true,
        displayModeBar: true,
        displaylogo: false
      };

      Plotly.newPlot('plot', [edgeTrace, nodeTrace], layout, config);

      // ==============================================================================
      // é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
      // ==============================================================================
      document.getElementById('stats').innerHTML = `
        <b>ğŸ“Š è³‡æ–™çµ±è¨ˆ:</b><br>
        ç¯€é»æ•¸: ${metadata.total_nodes}<br>
        é‚Šæ•¸: ${metadata.sampled_edges} / ${metadata.total_edges}<br>
        å–æ¨£ç‡: ${(metadata.sample_rate * 100).toFixed(1)}%
      `;

      // ==============================================================================
      // é»æ“Šäº‹ä»¶
      // ==============================================================================
      const plotDiv = document.getElementById('plot');
      const nodeTraceIndex = 1;

      plotDiv.on('plotly_click', function(eventData) {
        const point = eventData.points[0];

        if (!point || point.curveNumber !== nodeTraceIndex) {
          return;
        }

        const nodeIndex = point.pointNumber;
        const node = nodes[nodeIndex];

        if (!node) return;

        // æ›´æ–°ç¯€é»é¡è‰²
        const newColors = Array(nodes.length).fill('#4a90e2');
        newColors[nodeIndex] = '#e74c3c';

        setTimeout(() => {
          try {
            Plotly.restyle('plot', { 'marker.color': [newColors] }, [nodeTraceIndex]);
          } catch (e) {
            console.error("Plotly restyle error:", e);
          }
        }, 0);

        // ğŸ¨ æ›´æ–°å³å´è³‡è¨Š (åŒ…å«åœ–ç‰‡)
        const tcIds = node.TC_ID || [];
        const times = node.time || [];
        const orders = node.order || [];

        // æ§‹å»ºåŸºæœ¬è³‡è¨Š
        let infoHTML = `
          <h3>ğŸŒ€ é¢±é¢¨ç‹€æ…‹</h3>
          <p><b>ç¯€é» ID:</b> ${node.id}</p>
          <p><b>ç‹€æ…‹åƒæ•¸:</b> ${node.info_text || 'N/A'}</p>
          <p><b>RMW:</b> ${node.RMW ? node.RMW.toFixed(1) : 'N/A'} km</p>
          <p><b>Vmax:</b> ${node.Vmax ? node.Vmax.toFixed(2) : 'N/A'} m/s</p>
          <p><b>IKE:</b> ${node.IKE ? node.IKE.toFixed(2) : 'N/A'} TJ</p>
          <p><b>åº§æ¨™:</b> (${node.x.toFixed(3)}, ${node.y.toFixed(3)}, ${node.z.toFixed(3)})</p>
        `;

        // å¦‚æœæœ‰é¢±é¢¨ç·¨è™Ÿ,é¡¯ç¤ºåˆ—è¡¨
        if (tcIds.length > 0) {
          infoHTML += `<hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">`;
          infoHTML += `<p><b>é¢±é¢¨ç·¨è™Ÿ:</b> ${tcIds.join(', ')}</p>`;
          infoHTML += `<p><b>æ™‚é–“:</b> ${times[0] || 'N/A'}</p>`;
          infoHTML += `<p><b>é †åº:</b> ${orders.join(', ')}</p>`;
        }

        infoHTML += `<hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">`;
        infoHTML += `<div id="image-container" class="image-container"></div>`;
        infoHTML += document.getElementById('stats').outerHTML;

        document.getElementById('node-info').innerHTML = infoHTML;

        // ğŸ–¼ï¸ éåŒæ­¥è¼‰å…¥åœ–ç‰‡
        const imageContainer = document.getElementById('image-container');
        if (tcIds.length > 0 && times.length > 0 && orders.length > 0) {
          loadMultipleTyphoonImages(tcIds, times, orders, imageContainer);
        } else {
          imageContainer.innerHTML = '<div class="image-loading" style="color: #999;">âš ï¸ ç„¡åœ–ç‰‡è³‡è¨Š</div>';
        }
      });

      console.log(`
      âœ… åœ–è¡¨æ¸²æŸ“å®Œæˆ!
      ğŸ“Š çµ±è¨ˆ:
      - ç¯€é»æ•¸: ${metadata.total_nodes}
      - é‚Šæ•¸: ${metadata.sampled_edges}
      - é‚Šçš„åº§æ¨™é™£åˆ—é•·åº¦: x=${edgeData.x.length}, y=${edgeData.y.length}, z=${edgeData.z.length}
      `);

    } catch (error) {
      console.error('âŒ åˆå§‹åŒ–å¤±æ•—:', error);
      document.getElementById('loading').innerHTML = `
        <div style="color: red;">âŒ ç™¼ç”ŸéŒ¯èª¤</div>
        <div style="font-size: 0.9em; margin-top: 10px;">${error.message}</div>
      `;
    }
  })();
  </script>
</body>
</html>